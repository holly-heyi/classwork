%经典pid,Matlab实现
clear all;
close all;
ts=0.1;  %采样时间=0.1s
sys=tf(4.23,[1,1.64,8.46],'ioDelay',3) %建立被控对象传递函数
dsys=c2d(sys,ts,'z')     %离散化
[num,den]=tfdata(dsys,'v');   %
e_1=0;      %前一时刻的偏差      
Ee=0;       %累积偏差
%X={0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0}
%[u_1,u_2,u_3,u_4,u_5,u_6,u_7,u_8,u_9,u_10,u_11,u_12,u_13,u_14,u_15,u_16,u_17,u_18,u_19,u_20,u_21,u_22,u_23,u_24,u_25,u_26,u_27,u_28,u_29,u_30,u_31,u_32,u_33]=deal(X{:});    
%前一时刻的控制量
%y_1=0; y_2=0;      %前一时刻的输出
%PID参数
% kp=0.35;    
% ki=0.02;
% kd=0.9;
 kp=0.36;     ki=0.035; kd=0.3
u=zeros(1,1000);
for j=1:32;%差分方程，0时刻前的32个点
    u(j)=0.0;
end
%y=zeros(1,2);%预先分配内存

time=zeros(1,1000);%时刻点（设定1000个）
for k=1:1:1000
    time(k)=(k)*ts;   %时间参数
    r(k)=1;      %期望值
    y(1)=0;y(2)=0;
    y(k+2)=-1*den(3)*y(k-2+2)-1*den(2)*y(k-1+2)+num(2)*u(k-31+32)+num(3)*u(k-32+32);%系统响应输出序列
    e(k)=r(k)-y(k+2);   %误差信号
    m=e(k)-e_1;
    u(k+32)=kp*e(k)+ki*Ee+kd*m; %系统PID控制器输出序列
    Ee=Ee+e(k);    %误差的累加和
    %前一个的控制器输出值
    %y_1=y(k);y_2=y(k-1);
    %前一个的系统响应输出值
    e_1=e(k);		%前一个误差信号的值
end
%（仅绘制过渡过程的曲线，x坐标限制为[0,1]）
%p1=plot(time,r,'*');xlim([0,100]);hold on;%指令信号的曲线（即期望输入）
p2=plot(time,y(3:1002),'--');xlim([0,100]);ylim([0,1.2]);grid on;%不含积分分离的PID曲线
hold on;
